/**
 * Generated by orval v7.0.1 ðŸº
 * Do not edit manually.
 * Agora's OP API (Beta)
 * Welcome to the Collective API documentation. This API provides various endpoints to interact with the Collective platform, focusing on RetroPGF (Retroactive Public Goods Funding) for Optimism. Below is a comprehensive guide to the API endpoints, categorized by functionality.

### Current Status
- **Beta**: This API is currently in beta. Endpoints marked as "Not Live" are under development and available for feedback only.

### API Categories
Live and stable. 
- **auth**: Authenticate with the Agora API
- **Round 4**: Data related to Retro Funding for Optimism Round 4
- **RetroFunding**: Data related to Retro Funding for Optimism Round 4 and beyond
- **projects**: Data related to RetroPGF Projects
- **RetroFundingRounds**: Data related to RetroPGF Funding Rounds
- **RetroFundingBallots**: Data related to RetroPGF Funding Ballots
- **impactMetrics**: Data related to the Impact Metrics for RetroFunding Round 4
- **RetroFundingImpactMetrics**: Connect RetroPGF to Impact Metrics
- **comments**: Data related to RetroPGF Project Comments
- **commentsVotes**: Data related to RetroPGF Project Comments' Votes
- **delegates**: Delegates data
- **delegations**: Delegations data
- **proposals**: Proposal data
- **votes**: Vote data
- **contracts**: Data for the current onchain contracts
- **projects** Round 5 Projects with mock data
- **RetroFundingBallots** Round 5 Ballots with mock data

Not Live.
- **Round 5**: Data related to Retro Funding for Optimism Round 5
- 0.2.2: **DistributionStrategies** Round 5 Distribution strategies with mock data
- 0.2.3: Round 5 Production release with real data

### Release Schedule

| Version  | Status  | Release Date  |
|----------|---------|---------------|
| OP 0.1.0 | LIVE   | June 7th |
| OP 0.1.1 | LIVE   | June 27th |
| OP 0.1.2 | LIVE   | July 22th |
| OP 0.1.3 | LIVE   | July 31th |
|----------|---------|---------------|
| OP 0.2.0 | LIVE   | Aug 10th |
| OP 0.2.1 | LIVE   | Aug 26th |
| OP 0.2.2 | ON TRACK   | Aug 30th |
| OP 0.2.3 | ON TRACK   | Sep 20th |
 * OpenAPI spec version: 0.2.1
 */
import type {
  AddImpactMetricToRetroFundingBallotBody,
  AuthToken,
  Comment,
  CommentVote,
  Contract,
  Delegate,
  Delegation,
  GetDelegateVotes200,
  GetDelegateVotesParams,
  GetDelegates200,
  GetDelegatesParams,
  GetDelegatorsByAddress200,
  GetImpactMetricComments200,
  GetImpactMetricCommentsParams,
  GetProjects200,
  GetProjectsParams,
  GetProposalVotes200,
  GetProposalVotesParams,
  GetProposals200,
  GetProposalsParams,
  GetRetroFundingRoundBallotById200,
  GetRetroFundingRoundBallots200,
  GetRetroFundingRoundBallotsParams,
  GetRetroFundingRoundProjects200,
  GetRetroFundingRoundProjectsParams,
  GetRetroFundingRounds200,
  GetRetroFundingRoundsParams,
  Project,
  Proposal,
  PutImactMetricCommentVoteBody,
  PutImpactMetricCommentBody,
  RecordImpactMetricView200,
  RetroFundingImpactMetric,
  RetroFundingRound,
  Round4Ballot,
  Round5Ballot,
  SIWEVerificationBody,
  SubmitRetroFundingBallot200,
  SubmitRetroFundingBallotBody,
  UpdateImpactMetricCommentBody,
  UpdateRetroFundingBallotDistributionMethodBody,
  UpdateRetroFundingRoundCategoryAllocationBody,
  VotingToken,
} from "./agora.schemas";
import { customFetch } from "../../lib/custom-fetch";

/**
 * Retrieves the full OAS/Swagger spec for the API in YAML.
 * @summary Gets this specification
 */
export type getSpecResponse = {
  data: string;
  status: number;
};

export const getGetSpecUrl = () => {
  return `/api/agora/spec`;
};

export const getSpec = async (
  options?: RequestInit,
): Promise<getSpecResponse> => {
  return customFetch<Promise<getSpecResponse>>(getGetSpecUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Gets nonce for SIWE authentication.
 * @summary Gets nonce for SIWE authentication
 */
export type getNonceResponse = {
  data: string;
  status: number;
};

export const getGetNonceUrl = () => {
  return `/api/agora/auth/nonce`;
};

export const getNonce = async (
  options?: RequestInit,
): Promise<getNonceResponse> => {
  return customFetch<Promise<getNonceResponse>>(getGetNonceUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Posts SIWE message and signature.
 * @summary Posts SIWE verification payload
 */
export type postSiweVerificationMessageResponse = {
  data: AuthToken;
  status: number;
};

export const getPostSiweVerificationMessageUrl = () => {
  return `/api/agora/auth/verify`;
};

export const postSiweVerificationMessage = async (
  sIWEVerificationBody: SIWEVerificationBody,
  options?: RequestInit,
): Promise<postSiweVerificationMessageResponse> => {
  return customFetch<Promise<postSiweVerificationMessageResponse>>(
    getPostSiweVerificationMessageUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(sIWEVerificationBody),
    },
  );
};

/**
 * Retrieves a list of voting delegates on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a list of delegates
 */
export type getDelegatesResponse = {
  data: GetDelegates200;
  status: number;
};

export const getGetDelegatesUrl = (params?: GetDelegatesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/delegates?${normalizedParams.toString()}`
    : `/api/agora/delegates`;
};

export const getDelegates = async (
  params?: GetDelegatesParams,
  options?: RequestInit,
): Promise<getDelegatesResponse> => {
  return customFetch<Promise<getDelegatesResponse>>(
    getGetDelegatesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific delegate on Agora by address or ENS name.

 * @summary Gets a specific delegate
 */
export type getDelegateByAddressResponse = {
  data: Delegate;
  status: number;
};

export const getGetDelegateByAddressUrl = (addressOrEnsName: string) => {
  return `/api/agora/delegates/${addressOrEnsName}`;
};

export const getDelegateByAddress = async (
  addressOrEnsName: string,
  options?: RequestInit,
): Promise<getDelegateByAddressResponse> => {
  return customFetch<Promise<getDelegateByAddressResponse>>(
    getGetDelegateByAddressUrl(addressOrEnsName),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a paginated list of votes for a specific proposal on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a paginated list of votes for a delegate
 */
export type getDelegateVotesResponse = {
  data: GetDelegateVotes200;
  status: number;
};

export const getGetDelegateVotesUrl = (
  addressOrEnsName: string,
  params?: GetDelegateVotesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/delegates/${addressOrEnsName}/votes?${normalizedParams.toString()}`
    : `/api/agora/delegates/${addressOrEnsName}/votes`;
};

export const getDelegateVotes = async (
  addressOrEnsName: string,
  params?: GetDelegateVotesParams,
  options?: RequestInit,
): Promise<getDelegateVotesResponse> => {
  return customFetch<Promise<getDelegateVotesResponse>>(
    getGetDelegateVotesUrl(addressOrEnsName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a list of voting proposals on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a list of proposals
 */
export type getProposalsResponse = {
  data: GetProposals200;
  status: number;
};

export const getGetProposalsUrl = (params?: GetProposalsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/proposals?${normalizedParams.toString()}`
    : `/api/agora/proposals`;
};

export const getProposals = async (
  params?: GetProposalsParams,
  options?: RequestInit,
): Promise<getProposalsResponse> => {
  return customFetch<Promise<getProposalsResponse>>(
    getGetProposalsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific voting proposal on Agora.

 * @summary Gets a specific proposal
 */
export type getProposalByIdResponse = {
  data: Proposal;
  status: number;
};

export const getGetProposalByIdUrl = (proposalId: string) => {
  return `/api/agora/proposals/${proposalId}`;
};

export const getProposalById = async (
  proposalId: string,
  options?: RequestInit,
): Promise<getProposalByIdResponse> => {
  return customFetch<Promise<getProposalByIdResponse>>(
    getGetProposalByIdUrl(proposalId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a paginated list of votes for a specific proposal on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a paginated list of votes for a proposal
 */
export type getProposalVotesResponse = {
  data: GetProposalVotes200;
  status: number;
};

export const getGetProposalVotesUrl = (
  proposalId: string,
  params?: GetProposalVotesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/proposals/${proposalId}/votes?${normalizedParams.toString()}`
    : `/api/agora/proposals/${proposalId}/votes`;
};

export const getProposalVotes = async (
  proposalId: string,
  params?: GetProposalVotesParams,
  options?: RequestInit,
): Promise<getProposalVotesResponse> => {
  return customFetch<Promise<getProposalVotesResponse>>(
    getGetProposalVotesUrl(proposalId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a list of the delegatees for a given address. That is, the delegates to which the supplied address is delegating votes.

 * @summary Gets delegatees (delegating to) information for an address
 */
export type getDelegateesByAddressResponse = {
  data: Delegation;
  status: number;
};

export const getGetDelegateesByAddressUrl = (addressOrEnsName: string) => {
  return `/api/agora/delegates/${addressOrEnsName}/delegatees`;
};

export const getDelegateesByAddress = async (
  addressOrEnsName: string,
  options?: RequestInit,
): Promise<getDelegateesByAddressResponse> => {
  return customFetch<Promise<getDelegateesByAddressResponse>>(
    getGetDelegateesByAddressUrl(addressOrEnsName),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a paginated list of the delegators for a given address. That is, the delegates from which the supplied address is being delegated votes.

 * @summary Gets delegator (delegating to) information for an address
 */
export type getDelegatorsByAddressResponse = {
  data: GetDelegatorsByAddress200;
  status: number;
};

export const getGetDelegatorsByAddressUrl = (addressOrEnsName: string) => {
  return `/api/agora/delegates/${addressOrEnsName}/delegators`;
};

export const getDelegatorsByAddress = async (
  addressOrEnsName: string,
  options?: RequestInit,
): Promise<getDelegatorsByAddressResponse> => {
  return customFetch<Promise<getDelegatorsByAddressResponse>>(
    getGetDelegatorsByAddressUrl(addressOrEnsName),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves the address of the governor contract on chain.

 * @summary Gets the governor contract address
 */
export type getGovernorContractResponse = {
  data: Contract;
  status: number;
};

export const getGetGovernorContractUrl = () => {
  return `/api/agora/contracts/governor`;
};

export const getGovernorContract = async (
  options?: RequestInit,
): Promise<getGovernorContractResponse> => {
  return customFetch<Promise<getGovernorContractResponse>>(
    getGetGovernorContractUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves the address of the alligator contract on chain.

 * @summary Gets the alligator contract address
 */
export type getAlligatorContractResponse = {
  data: Contract;
  status: number;
};

export const getGetAlligatorContractUrl = () => {
  return `/api/agora/contracts/alligator`;
};

export const getAlligatorContract = async (
  options?: RequestInit,
): Promise<getAlligatorContractResponse> => {
  return customFetch<Promise<getAlligatorContractResponse>>(
    getGetAlligatorContractUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves the address of the voting token contract on chain.

 * @summary Gets the voting token contract address
 */
export type getVotingTokenContractResponse = {
  data: VotingToken;
  status: number;
};

export const getGetVotingTokenContractUrl = () => {
  return `/api/agora/contracts/token`;
};

export const getVotingTokenContract = async (
  options?: RequestInit,
): Promise<getVotingTokenContractResponse> => {
  return customFetch<Promise<getVotingTokenContractResponse>>(
    getGetVotingTokenContractUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a list of projects on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a list of projects
 */
export type getProjectsResponse = {
  data: GetProjects200;
  status: number;
};

export const getGetProjectsUrl = (params?: GetProjectsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/projects?${normalizedParams.toString()}`
    : `/api/agora/projects`;
};

export const getProjects = async (
  params?: GetProjectsParams,
  options?: RequestInit,
): Promise<getProjectsResponse> => {
  return customFetch<Promise<getProjectsResponse>>(getGetProjectsUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * Retrieves a paginated list of RetroFunding rounds, ordered by round ID.

 * @summary Gets a list of RetroFunding rounds
 */
export type getRetroFundingRoundsResponse = {
  data: GetRetroFundingRounds200;
  status: number;
};

export const getGetRetroFundingRoundsUrl = (
  params?: GetRetroFundingRoundsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/retrofunding/rounds?${normalizedParams.toString()}`
    : `/api/agora/retrofunding/rounds`;
};

export const getRetroFundingRounds = async (
  params?: GetRetroFundingRoundsParams,
  options?: RequestInit,
): Promise<getRetroFundingRoundsResponse> => {
  return customFetch<Promise<getRetroFundingRoundsResponse>>(
    getGetRetroFundingRoundsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific RetroFunding round on Agora.

 * @summary Gets a specific RetroFunding round
 */
export type getRetroFundingRoundByIdResponse = {
  data: RetroFundingRound;
  status: number;
};

export const getGetRetroFundingRoundByIdUrl = (roundId: number) => {
  return `/api/agora/retrofunding/rounds/${roundId}`;
};

export const getRetroFundingRoundById = async (
  roundId: number,
  options?: RequestInit,
): Promise<getRetroFundingRoundByIdResponse> => {
  return customFetch<Promise<getRetroFundingRoundByIdResponse>>(
    getGetRetroFundingRoundByIdUrl(roundId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a list of ballots for a specific RetroFunding round on Agora as a JSON array. Limit, offset parameters can be used to customize the returned list sorted by ballot ordinal.

 * @summary Gets a list of ballots for an RetroFunding round
 */
export type getRetroFundingRoundBallotsResponse = {
  data: GetRetroFundingRoundBallots200;
  status: number;
};

export const getGetRetroFundingRoundBallotsUrl = (
  roundId: number,
  params?: GetRetroFundingRoundBallotsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/retrofunding/rounds/${roundId}/ballots?${normalizedParams.toString()}`
    : `/api/agora/retrofunding/rounds/${roundId}/ballots`;
};

export const getRetroFundingRoundBallots = async (
  roundId: number,
  params?: GetRetroFundingRoundBallotsParams,
  options?: RequestInit,
): Promise<getRetroFundingRoundBallotsResponse> => {
  return customFetch<Promise<getRetroFundingRoundBallotsResponse>>(
    getGetRetroFundingRoundBallotsUrl(roundId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific ballot for an RetroFunding round on Agora.

 * @summary Gets a specific ballot for an RetroFunding round
 */
export type getRetroFundingRoundBallotByIdResponse = {
  data: GetRetroFundingRoundBallotById200;
  status: number;
};

export const getGetRetroFundingRoundBallotByIdUrl = (
  roundId: number,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}`;
};

export const getRetroFundingRoundBallotById = async (
  roundId: number,
  addressOrEnsName: string,
  options?: RequestInit,
): Promise<getRetroFundingRoundBallotByIdResponse> => {
  return customFetch<Promise<getRetroFundingRoundBallotByIdResponse>>(
    getGetRetroFundingRoundBallotByIdUrl(roundId, addressOrEnsName),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Updates the OS only flag for a specific ballot for an RetroFunding round on Agora.

 * @summary Updates the OS only flag for a specific RetroFunding ballot
 */
export type updateRetroFundingBallotOSOnlyResponse = {
  data: Round4Ballot;
  status: number;
};

export const getUpdateRetroFundingBallotOSOnlyUrl = (
  roundId: number,
  addressOrEnsName: string,
  osOnly: boolean,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/osOnly/${osOnly}`;
};

export const updateRetroFundingBallotOSOnly = async (
  roundId: number,
  addressOrEnsName: string,
  osOnly: boolean,
  options?: RequestInit,
): Promise<updateRetroFundingBallotOSOnlyResponse> => {
  return customFetch<Promise<updateRetroFundingBallotOSOnlyResponse>>(
    getUpdateRetroFundingBallotOSOnlyUrl(roundId, addressOrEnsName, osOnly),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Submits the content of a ballot to be counted as final for the round.
 * @summary Submits a particular ballot
 */
export type submitRetroFundingBallotResponse = {
  data: SubmitRetroFundingBallot200;
  status: number;
};

export const getSubmitRetroFundingBallotUrl = (
  roundId: number,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/submit`;
};

export const submitRetroFundingBallot = async (
  roundId: number,
  addressOrEnsName: string,
  submitRetroFundingBallotBody: SubmitRetroFundingBallotBody,
  options?: RequestInit,
): Promise<submitRetroFundingBallotResponse> => {
  return customFetch<Promise<submitRetroFundingBallotResponse>>(
    getSubmitRetroFundingBallotUrl(roundId, addressOrEnsName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(submitRetroFundingBallotBody),
    },
  );
};

/**
 * Retrieves a list of projects for a specific RetroFunding round on Agora as a JSON array. Limit, offset, and sort parameters can be used to customize the returned list.

 * @summary Gets a list of projects for an RetroFunding round
 */
export type getRetroFundingRoundProjectsResponse = {
  data: GetRetroFundingRoundProjects200;
  status: number;
};

export const getGetRetroFundingRoundProjectsUrl = (
  roundId: number,
  params?: GetRetroFundingRoundProjectsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/retrofunding/rounds/${roundId}/projects?${normalizedParams.toString()}`
    : `/api/agora/retrofunding/rounds/${roundId}/projects`;
};

export const getRetroFundingRoundProjects = async (
  roundId: number,
  params?: GetRetroFundingRoundProjectsParams,
  options?: RequestInit,
): Promise<getRetroFundingRoundProjectsResponse> => {
  return customFetch<Promise<getRetroFundingRoundProjectsResponse>>(
    getGetRetroFundingRoundProjectsUrl(roundId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific project for a specific RetroFunding round on Agora.

 * @summary Gets a specific project for an RetroFunding round
 */
export type getRetroFundingRoundProjectByIdResponse = {
  data: Project;
  status: number;
};

export const getGetRetroFundingRoundProjectByIdUrl = (
  roundId: number,
  projectId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/projects/${projectId}`;
};

export const getRetroFundingRoundProjectById = async (
  roundId: number,
  projectId: string,
  options?: RequestInit,
): Promise<getRetroFundingRoundProjectByIdResponse> => {
  return customFetch<Promise<getRetroFundingRoundProjectByIdResponse>>(
    getGetRetroFundingRoundProjectByIdUrl(roundId, projectId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Adds an impact metric or updates an existing impact metric's allocation amount  on a specific ballot for an RetroFunding round on Agora.

 * @summary Adds or updates an impact metric on a specific RetroFunding ballot
 */
export type addImpactMetricToRetroFundingBallotResponse = {
  data: Round4Ballot;
  status: number;
};

export const getAddImpactMetricToRetroFundingBallotUrl = (
  roundId: number,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/impactMetrics`;
};

export const addImpactMetricToRetroFundingBallot = async (
  roundId: number,
  addressOrEnsName: string,
  addImpactMetricToRetroFundingBallotBody: AddImpactMetricToRetroFundingBallotBody,
  options?: RequestInit,
): Promise<addImpactMetricToRetroFundingBallotResponse> => {
  return customFetch<Promise<addImpactMetricToRetroFundingBallotResponse>>(
    getAddImpactMetricToRetroFundingBallotUrl(roundId, addressOrEnsName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(addImpactMetricToRetroFundingBallotBody),
    },
  );
};

/**
 * Updates a specific project for a specific RetroFunding round on Agora. Allocation is a percentage of total allocation for the round.

 * @summary Updates allocation for a specific project for a RetroFunding round
 */
export type updateRetroFundingRoundProjectAllocationResponse = {
  data: Round5Ballot;
  status: number;
};

export const getUpdateRetroFundingRoundProjectAllocationUrl = (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  allocation: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/projects/${projectId}/allocation/${allocation}`;
};

export const updateRetroFundingRoundProjectAllocation = async (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  allocation: string,
  options?: RequestInit,
): Promise<updateRetroFundingRoundProjectAllocationResponse> => {
  return customFetch<Promise<updateRetroFundingRoundProjectAllocationResponse>>(
    getUpdateRetroFundingRoundProjectAllocationUrl(
      roundId,
      addressOrEnsName,
      projectId,
      allocation,
    ),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Updates a specific project for a specific RetroFunding round on Agora. Impact is a number from 0 to 5. 0 - Conflict of Interest 1 - Very Low 2 - Low 3 - Medium 4 - High 5 - Very High

 * @summary Updates impact for a specific project for a RetroFunding round
 */
export type updateRetroFundingRoundProjectImpactResponse = {
  data: Round5Ballot;
  status: number;
};

export const getUpdateRetroFundingRoundProjectImpactUrl = (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  impact: number,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/projects/${projectId}/impact/${impact}`;
};

export const updateRetroFundingRoundProjectImpact = async (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  impact: number,
  options?: RequestInit,
): Promise<updateRetroFundingRoundProjectImpactResponse> => {
  return customFetch<Promise<updateRetroFundingRoundProjectImpactResponse>>(
    getUpdateRetroFundingRoundProjectImpactUrl(
      roundId,
      addressOrEnsName,
      projectId,
      impact,
    ),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Updates a specific project for a specific RetroFunding round on Agora. Postion is an integer of the project's rank.

 * @summary Updates position for a specific project for a RetroFunding round
 */
export type updateRetroFundingRoundProjectPositionResponse = {
  data: Round5Ballot;
  status: number;
};

export const getUpdateRetroFundingRoundProjectPositionUrl = (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  position: number,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/projects/${projectId}/position/${position}`;
};

export const updateRetroFundingRoundProjectPosition = async (
  roundId: number,
  addressOrEnsName: string,
  projectId: string,
  position: number,
  options?: RequestInit,
): Promise<updateRetroFundingRoundProjectPositionResponse> => {
  return customFetch<Promise<updateRetroFundingRoundProjectPositionResponse>>(
    getUpdateRetroFundingRoundProjectPositionUrl(
      roundId,
      addressOrEnsName,
      projectId,
      position,
    ),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Updates a category allocation and lock status for a specific ballot for a RetroFunding round on Agora.

 * @summary Updates a category allocation for a specific RetroFunding ballot
 */
export type updateRetroFundingRoundCategoryAllocationResponse = {
  data: Round5Ballot;
  status: number;
};

export const getUpdateRetroFundingRoundCategoryAllocationUrl = (
  roundId: number,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/categories`;
};

export const updateRetroFundingRoundCategoryAllocation = async (
  roundId: number,
  addressOrEnsName: string,
  updateRetroFundingRoundCategoryAllocationBody: UpdateRetroFundingRoundCategoryAllocationBody,
  options?: RequestInit,
): Promise<updateRetroFundingRoundCategoryAllocationResponse> => {
  return customFetch<
    Promise<updateRetroFundingRoundCategoryAllocationResponse>
  >(
    getUpdateRetroFundingRoundCategoryAllocationUrl(roundId, addressOrEnsName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(updateRetroFundingRoundCategoryAllocationBody),
    },
  );
};

/**
 * Updates the distribution method for a specific ballot for a RetroFunding round on Agora.

 * @summary Updates the distribution method for a specific RetroFunding ballot
 */
export type updateRetroFundingBallotDistributionMethodResponse = {
  data: Round5Ballot;
  status: number;
};

export const getUpdateRetroFundingBallotDistributionMethodUrl = (
  roundId: number,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/distribution_method`;
};

export const updateRetroFundingBallotDistributionMethod = async (
  roundId: number,
  addressOrEnsName: string,
  updateRetroFundingBallotDistributionMethodBody: UpdateRetroFundingBallotDistributionMethodBody,
  options?: RequestInit,
): Promise<updateRetroFundingBallotDistributionMethodResponse> => {
  return customFetch<
    Promise<updateRetroFundingBallotDistributionMethodResponse>
  >(
    getUpdateRetroFundingBallotDistributionMethodUrl(roundId, addressOrEnsName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(updateRetroFundingBallotDistributionMethodBody),
    },
  );
};

/**
 * Removes an impact metric from a specific ballot for a RetroFunding round on Agora.

 * @summary Removes an impact metric from a ballot
 */
export type removeImpactMetricFromRetroFundingBallotResponse = {
  data: void;
  status: number;
};

export const getRemoveImpactMetricFromRetroFundingBallotUrl = (
  roundId: number,
  addressOrEnsName: string,
  impactMetricId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/ballots/${addressOrEnsName}/impactMetrics/${impactMetricId}`;
};

export const removeImpactMetricFromRetroFundingBallot = async (
  roundId: number,
  addressOrEnsName: string,
  impactMetricId: string,
  options?: RequestInit,
): Promise<removeImpactMetricFromRetroFundingBallotResponse> => {
  return customFetch<Promise<removeImpactMetricFromRetroFundingBallotResponse>>(
    getRemoveImpactMetricFromRetroFundingBallotUrl(
      roundId,
      addressOrEnsName,
      impactMetricId,
    ),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Retrieves a paginated list of impact metrics for a specific RetroFunding round on Agora.

 * @summary Gets impact metrics for a specific RetroFunding round
 */
export type getImpactMetricsOnRetroFundingRoundResponse = {
  data: RetroFundingImpactMetric[];
  status: number;
};

export const getGetImpactMetricsOnRetroFundingRoundUrl = (roundId: number) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics`;
};

export const getImpactMetricsOnRetroFundingRound = async (
  roundId: number,
  options?: RequestInit,
): Promise<getImpactMetricsOnRetroFundingRoundResponse> => {
  return customFetch<Promise<getImpactMetricsOnRetroFundingRoundResponse>>(
    getGetImpactMetricsOnRetroFundingRoundUrl(roundId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieves a specific impact metric for a specific RetroFunding round on Agora.

 * @summary Gets a specific impact metric for an RetroFunding round
 */
export type getImpactMetricOnRetroFundingRoundResponse = {
  data: RetroFundingImpactMetric;
  status: number;
};

export const getGetImpactMetricOnRetroFundingRoundUrl = (
  roundId: number,
  impactMetricId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}`;
};

export const getImpactMetricOnRetroFundingRound = async (
  roundId: number,
  impactMetricId: string,
  options?: RequestInit,
): Promise<getImpactMetricOnRetroFundingRoundResponse> => {
  return customFetch<Promise<getImpactMetricOnRetroFundingRoundResponse>>(
    getGetImpactMetricOnRetroFundingRoundUrl(roundId, impactMetricId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Records a view of an impact metric by a specific address or ENS name

 * @summary Records a view of an impact metric
 */
export type recordImpactMetricViewResponse = {
  data: RecordImpactMetricView200;
  status: number;
};

export const getRecordImpactMetricViewUrl = (
  roundId: number,
  impactMetricId: string,
  addressOrEnsName: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/${addressOrEnsName}`;
};

export const recordImpactMetricView = async (
  roundId: number,
  impactMetricId: string,
  addressOrEnsName: string,
  options?: RequestInit,
): Promise<recordImpactMetricViewResponse> => {
  return customFetch<Promise<recordImpactMetricViewResponse>>(
    getRecordImpactMetricViewUrl(roundId, impactMetricId, addressOrEnsName),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Gets a paginated list of comments on a particular impact metric. Ordered by creation date.

 * @summary Gets comments on an impact metric
 */
export type getImpactMetricCommentsResponse = {
  data: GetImpactMetricComments200;
  status: number;
};

export const getGetImpactMetricCommentsUrl = (
  roundId: number,
  impactMetricId: string,
  params?: GetImpactMetricCommentsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return normalizedParams.size
    ? `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments?${normalizedParams.toString()}`
    : `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments`;
};

export const getImpactMetricComments = async (
  roundId: number,
  impactMetricId: string,
  params?: GetImpactMetricCommentsParams,
  options?: RequestInit,
): Promise<getImpactMetricCommentsResponse> => {
  return customFetch<Promise<getImpactMetricCommentsResponse>>(
    getGetImpactMetricCommentsUrl(roundId, impactMetricId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Creates a comment on a specific impact metric for a specific round. Returns created comment.

 * @summary Creates a comment on an impact metric
 */
export type putImpactMetricCommentResponse = {
  data: Comment;
  status: number;
};

export const getPutImpactMetricCommentUrl = (
  roundId: number,
  impactMetricId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments`;
};

export const putImpactMetricComment = async (
  roundId: number,
  impactMetricId: string,
  putImpactMetricCommentBody: PutImpactMetricCommentBody,
  options?: RequestInit,
): Promise<putImpactMetricCommentResponse> => {
  return customFetch<Promise<putImpactMetricCommentResponse>>(
    getPutImpactMetricCommentUrl(roundId, impactMetricId),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(putImpactMetricCommentBody),
    },
  );
};

/**
 * Gets a specific comment on a particular impact metric.

 * @summary Gets a specific comment on an impact metric
 */
export type getImpactMetricCommentResponse = {
  data: Comment;
  status: number;
};

export const getGetImpactMetricCommentUrl = (
  roundId: number,
  impactMetricId: string,
  commentId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments/${commentId}`;
};

export const getImpactMetricComment = async (
  roundId: number,
  impactMetricId: string,
  commentId: string,
  options?: RequestInit,
): Promise<getImpactMetricCommentResponse> => {
  return customFetch<Promise<getImpactMetricCommentResponse>>(
    getGetImpactMetricCommentUrl(roundId, impactMetricId, commentId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Updates a comment on a specific impact metric for a specific round. Returns updated comment.

 * @summary Updates existing comment
 */
export type updateImpactMetricCommentResponse = {
  data: Comment;
  status: number;
};

export const getUpdateImpactMetricCommentUrl = (
  roundId: number,
  impactMetricId: string,
  commentId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments/${commentId}`;
};

export const updateImpactMetricComment = async (
  roundId: number,
  impactMetricId: string,
  commentId: string,
  updateImpactMetricCommentBody: UpdateImpactMetricCommentBody,
  options?: RequestInit,
): Promise<updateImpactMetricCommentResponse> => {
  return customFetch<Promise<updateImpactMetricCommentResponse>>(
    getUpdateImpactMetricCommentUrl(roundId, impactMetricId, commentId),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(updateImpactMetricCommentBody),
    },
  );
};

/**
 * Deletes a comment on a specific impact metric for a specific round.

 * @summary Deletes a comment on an impact metric
 */
export type deleteImpactMetricCommentResponse = {
  data: void;
  status: number;
};

export const getDeleteImpactMetricCommentUrl = (
  roundId: number,
  impactMetricId: string,
  commentId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments/${commentId}`;
};

export const deleteImpactMetricComment = async (
  roundId: number,
  impactMetricId: string,
  commentId: string,
  options?: RequestInit,
): Promise<deleteImpactMetricCommentResponse> => {
  return customFetch<Promise<deleteImpactMetricCommentResponse>>(
    getDeleteImpactMetricCommentUrl(roundId, impactMetricId, commentId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Gets all votes for a speciffic comment

 * @summary Gets all votes for a speciffic comment
 */
export type getImpactMetricCommentVoteResponse = {
  data: CommentVote[];
  status: number;
};

export const getGetImpactMetricCommentVoteUrl = (
  roundId: number,
  impactMetricId: string,
  commentId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments/${commentId}/votes`;
};

export const getImpactMetricCommentVote = async (
  roundId: number,
  impactMetricId: string,
  commentId: string,
  options?: RequestInit,
): Promise<getImpactMetricCommentVoteResponse> => {
  return customFetch<Promise<getImpactMetricCommentVoteResponse>>(
    getGetImpactMetricCommentVoteUrl(roundId, impactMetricId, commentId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Creates or updates vote for a speciffic comment. Address of the voter is taken from the auth token. Input is a number, where 1 is upvote, -1 is downvote, 0 is neutral.

 * @summary Creates or updates vote for a speciffic comment
 */
export type putImactMetricCommentVoteResponse = {
  data: CommentVote;
  status: number;
};

export const getPutImactMetricCommentVoteUrl = (
  roundId: number,
  impactMetricId: string,
  commentId: string,
) => {
  return `/api/agora/retrofunding/rounds/${roundId}/impactMetrics/${impactMetricId}/comments/${commentId}/votes`;
};

export const putImactMetricCommentVote = async (
  roundId: number,
  impactMetricId: string,
  commentId: string,
  putImactMetricCommentVoteBody: PutImactMetricCommentVoteBody,
  options?: RequestInit,
): Promise<putImactMetricCommentVoteResponse> => {
  return customFetch<Promise<putImactMetricCommentVoteResponse>>(
    getPutImactMetricCommentVoteUrl(roundId, impactMetricId, commentId),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(putImactMetricCommentVoteBody),
    },
  );
};
